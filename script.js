/**
 * @description Handles the audio and visual feedback for key presses in the drum simulator.
 * @param {KeyboardEvent} event The event object generated by the keydown action.
 */
function playSound(event) {
	const { keyCode } = event;
	const audio = document.querySelector(`audio[data-key="${keyCode}"]`);
	const keyElement = document.querySelector(`.key[data-key="${keyCode}"]`);

	// S: Single Responsibility - Esta função tem a única responsabilidade de tocar um som.
	// I: Interface Segregation - A função depende apenas da interface do KeyboardEvent (keyCode).
	if (!audio) return; // Se não houver áudio para a tecla, interrompe a execução.

	// O: Open/Closed Principle - A lógica está fechada para modificação, mas aberta para extensão
	// (novos sons podem ser adicionados no HTML sem alterar este código).
	keyElement.classList.add('playing');
	audio.currentTime = 0; // Permite que o som seja tocado repetidamente.
	audio.play();
}

/**
 * @description Removes the visual 'playing' effect after the CSS transition ends.
 * @param {TransitionEvent} event The event object generated by the transitionend action.
 */
function removeTransition(event) {
	// Ignora outros eventos de transição que não sejam 'transform'.
	// L: Liskov Substitution - O tratamento do evento é consistente.
	if (event.propertyName !== 'transform') return;

	// D: Dependency Inversion - A lógica de alto nível (remover classe) não depende
	// dos detalhes de baixo nível (o próprio elemento), mas da abstração 'this'.
	this.classList.remove('playing');
}

// Seleciona todas as teclas uma única vez para otimizar a performance.
const keys = document.querySelectorAll('.key');

// DRY: Don't Repeat Yourself - O mesmo 'listener' é aplicado a todas as teclas num loop,
// evitando a repetição de código.
keys.forEach((key) => key.addEventListener('transitionend', removeTransition));
window.addEventListener('keydown', playSound);
